Дополнительные типы: структуры, срезы и карты.
Узнайте, как определять типы на основе существующих: этот урок охватывает структуры, массивы, срезы и карты.

Авторы Go
https://golang.org

* Указатели

В Go есть указатели.
Указатель хранит адрес памяти значения.

Тип `*T` - это указатель на значение типа `T`. Его нулевое значение - `nil`.

	var p *int

Оператор `&` генерирует указатель на свой операнд.

	i := 42
	p = &i

Оператор `*` обозначает базовое значение указателя.

	fmt.Println(*p) // читаем i через указатель p
	*p = 21         // устанавливаем i через указатель p

Это называется "разыменованием" или "косвенным обращением".

В отличие от C, в Go нет арифметики указателей.

.play moretypes/pointers.go

* Структуры

`struct` (структура) - это набор полей.

.play moretypes/structs.go

* Поля структуры

Доступ к полям структуры осуществляется через точку.

.play moretypes/struct-fields.go

* Указатели на структуры

Доступ к полям структуры можно получить через указатель на структуру.

Чтобы получить доступ к полю `X` структуры, когда у нас есть указатель на структуру `p`, мы могли бы
написать `(*p).X`.
Однако такая запись громоздка, поэтому язык позволяет нам вместо этого
писать просто `p.X`, без явного разыменования.

.play moretypes/struct-pointers.go

* Литералы структур

Литерал структуры обозначает вновь выделенное значение структуры, перечисляя значения её полей.

Вы можете перечислить только подмножество полей, используя синтаксис `Имя:`. (И порядок именованных полей не имеет значения.)

Специальный префикс `&` возвращает указатель на значение структуры.

.play moretypes/struct-literals.go


* Массивы

Тип `[n]T` - это массив из `n` значений типа `T`.

Выражение

	var a [10]int

объявляет переменную `a` как массив из десяти целых чисел.

Длина массива является частью его типа, поэтому массивы не могут быть изменены в размере.
Это кажется ограничивающим, но не беспокойтесь;
Go предоставляет удобный способ работы с массивами.

.play moretypes/array.go


* Срезы

Массив имеет фиксированный размер.
Срез, с другой стороны, - это динамически изменяемый по размеру,
гибкий вид на элементы массива.
На практике срезы гораздо более распространены, чем массивы.

Тип `[]T` - это срез с элементами типа `T`.

Срез формируется путем указания двух индексов, нижней и
верхней границы, разделенных двоеточием:

	a[low : high]

Это выбирает полуоткрытый диапазон, который включает первый
элемент, но исключает последний.

Следующее выражение создает срез, который включает
элементы с 1 по 3 из `a`:

	a[1:4]

.play moretypes/slices.go


* Срезы похожи на ссылки на массивы

Срез не хранит никаких данных,
он просто описывает раздел базового массива.

Изменение элементов среза изменяет
соответствующие элементы его базового массива.

Другие срезы, которые используют тот же базовый массив, увидят эти изменения.

.play moretypes/slices-pointers.go


* Литералы срезов

Литерал среза похож на литерал массива без указания длины.

Это литерал массива:

	[3]bool{true, true, false}

А это создает тот же массив, что и выше,
а затем создает срез, который ссылается на него:

	[]bool{true, true, false}

.play moretypes/slice-literals.go


* Значения по умолчанию для срезов

При создании среза вы можете опустить верхнюю или нижнюю границу, чтобы использовать их значения по умолчанию.

По умолчанию нижняя граница равна нулю, а верхняя граница равна длине среза.

Для массива

	var a [10]int

эти выражения среза эквивалентны:

	a[0:10]
	a[:10]
	a[0:]
	a[:]

.play moretypes/slice-bounds.go


* Длина и емкость среза

Срез имеет как _длину_, так и _емкость_.

Длина среза - это количество элементов, которые он содержит.

Емкость среза - это количество элементов в базовом массиве,
считая от первого элемента в срезе.

Длину и емкость среза `s` можно получить с помощью выражений
`len(s)` и `cap(s)`.

Вы можете увеличить длину среза путем повторного создания среза,
при условии, что он имеет достаточную емкость.
Попробуйте изменить одну из операций со срезом в примере программы, чтобы расширить его
за пределы его емкости, и посмотрите, что произойдет.

.play moretypes/slice-len-cap.go


* Нулевые срезы

Нулевое значение среза - `nil`.

Нулевой срез имеет длину и емкость 0
и не имеет базового массива.

.play moretypes/nil-slices.go


* Создание среза с помощью make

Срезы могут быть созданы с помощью встроенной функции `make`;
так создаются динамически изменяемые по размеру массивы.

Функция `make` выделяет обнуленный массив
и возвращает срез, который ссылается на этот массив:

	a := make([]int, 5)  // len(a)=5

Чтобы указать емкость, передайте третий аргумент в `make`:

	b := make([]int, 0, 5) // len(b)=0, cap(b)=5

	b = b[:cap(b)] // len(b)=5, cap(b)=5
	b = b[1:]      // len(b)=4, cap(b)=4

.play moretypes/making-slices.go


* Срезы срезов

Срезы могут содержать любой тип, включая другие срезы.

.play moretypes/slices-of-slice.go


* Добавление элементов в срез

Часто требуется добавлять новые элементы в срез, и Go предоставляет встроенную
функцию `append`. [[https://golang.org/pkg/builtin/#append][Документация]]
встроенного пакета описывает `append`.

	func append(s []T, vs ...T) []T

Первый параметр `s` функции `append` - это срез типа `T`, а остальные -
значения типа `T` для добавления к срезу.

Результирующее значение `append` - это срез, содержащий все элементы
исходного среза плюс предоставленные значения.

Если базовый массив `s` слишком мал, чтобы вместить все предоставленные значения, будет выделен более крупный
массив. Возвращаемый срез будет указывать на вновь выделенный
массив.

(Чтобы узнать больше о срезах, прочитайте статью [[https://blog.golang.org/go-slices-usage-and-internals][Срезы: использование и внутреннее устройство]].)

.play moretypes/append.go


* Range

Форма `range` цикла `for` выполняет итерацию по срезу или карте.

При итерации по срезу для каждой итерации возвращаются два значения.
Первое - это индекс, а второе - копия элемента с этим индексом.

.play moretypes/range.go

* Range (продолжение)

Вы можете пропустить индекс или значение, присвоив его `_`.

    for i, _ := range pow
    for _, value := range pow

Если вам нужен только индекс, вы можете опустить вторую переменную.

    for i := range pow

.play moretypes/range-continued.go

* Упражнение: Срезы

Реализуйте `Pic`. Она должна возвращать срез длины `dy`, каждый элемент которого - это срез из `dx` 8-битных беззнаковых целых чисел. Когда вы запустите программу, она отобразит ваше изображение, интерпретируя целые числа как значения оттенков серого (ну, на самом деле, оттенков синего).

Выбор изображения за вами. Интересные функции включают `(x+y)/2`, `x*y` и `x^y`.

(Вам нужно использовать цикл для выделения каждого `[]uint8` внутри `[][]uint8`.)

(Используйте `uint8(intValue)` для преобразования между типами.)

.play moretypes/exercise-slices.go

* Карты

Карта отображает ключи на значения.

Нулевое значение карты - `nil`.
Карта `nil` не имеет ключей, и ключи не могут быть добавлены.

Функция `make` возвращает карту указанного типа,
инициализированную и готовую к использованию.

.play moretypes/maps.go

* Литералы карт

Литералы карт похожи на литералы структур, но ключи обязательны.

.play moretypes/map-literals.go

* Литералы карт (продолжение)

Если тип верхнего уровня - просто имя типа, вы можете опустить его из элементов литерала.

.play moretypes/map-literals-continued.go

* Изменение карт

Вставка или обновление элемента в карте `m`:

	m[key] = elem

Получение элемента:

	elem = m[key]

Удаление элемента:

	delete(m, key)

Проверка наличия ключа с помощью присваивания двух значений:

	elem, ok = m[key]

Если `key` есть в `m`, то `ok` равно `true`. Если нет, то `ok` равно `false`.

Если `key` отсутствует в карте, то `elem` - это нулевое значение для типа элементов карты.

*Примечание:* Если `elem` или `ok` еще не были объявлены, вы можете использовать форму краткого объявления:

	elem, ok := m[key]

.play moretypes/mutating-maps.go

* Упражнение: Карты

Реализуйте `WordCount`. Она должна возвращать карту с количеством вхождений каждого "слова" в строке `s`. Функция `wc.Test` запускает набор тестов для предоставленной функции и выводит успех или неудачу.

Вам может пригодиться [[https://golang.org/pkg/strings/#Fields][strings.Fields]].

.play moretypes/exercise-maps.go

* Функции как значения

Функции тоже являются значениями. Они могут передаваться так же, как и другие значения.

Значения функций могут использоваться в качестве аргументов функций и возвращаемых значений.

.play moretypes/function-values.go

* Замыкания функций

Функции Go могут быть замыканиями. Замыкание - это значение функции, которое ссылается на переменные вне своего тела. Функция может обращаться к этим переменным и присваивать им значения; в этом смысле функция "привязана" к переменным.

Например, функция `adder` возвращает замыкание. Каждое замыкание привязано к своей собственной переменной `sum`.

.play moretypes/function-closures.go

* Упражнение: Замыкание Фибоначчи

Давайте немного повеселимся с функциями.

Реализуйте функцию `fibonacci`, которая возвращает функцию (замыкание), которая
возвращает последовательные [[https://en.wikipedia.org/wiki/Fibonacci_number][числа Фибоначчи]]
(0, 1, 1, 2, 3, 5, ...).

.play moretypes/exercise-fibonacci-closure.go

* Поздравляем!

Вы закончили этот урок!

Вы можете вернуться к списку [[/list][модулей]], чтобы узнать, что изучать дальше, или продолжить со [[javascript:click('.next-page')][следующим уроком]].
