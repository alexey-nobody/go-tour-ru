Операторы управления потоком: for, if, else, switch и defer
Узнайте, как управлять потоком вашего кода с помощью условий, циклов, переключателей и отложенных вызовов.

Авторы Go
https://golang.org

* For

В Go есть только одна циклическая конструкция - цикл `for`.

Базовый цикл `for` имеет три компонента, разделенных точкой с запятой:

- инициализирующее выражение: выполняется перед первой итерацией
- условное выражение: вычисляется перед каждой итерацией
- завершающее выражение: выполняется в конце каждой итерации

Инициализирующее выражение часто будет коротким объявлением переменной, и
переменные, объявленные там, видны только в области видимости оператора
`for`.

Цикл прекратит итерации, как только логическое условие будет вычислено как `false`.

*Примечание:* В отличие от других языков, таких как C, Java или JavaScript, нет скобок
вокруг трех компонентов оператора `for`, а фигурные скобки `{`}` 
всегда обязательны.

.play flowcontrol/for.go

* For (продолжение)

Инициализирующее и завершающее выражения являются необязательными.

.play flowcontrol/for-continued.go

* For - это "while" в Go

В этом случае вы можете опустить точки с запятой: `while` из C записывается как `for` в Go.

.play flowcontrol/for-is-gos-while.go

* Бесконечный цикл

Если вы опустите условие цикла, он будет выполняться бесконечно, так что бесконечный цикл выражается компактно.

.play flowcontrol/forever.go

* If

Операторы `if` в Go похожи на циклы `for`; выражение не обязательно
окружать скобками `(`)`, но фигурные скобки `{`}` обязательны.

.play flowcontrol/if.go

* If с коротким выражением

Как и `for`, оператор `if` может начинаться с короткого выражения, которое выполняется перед проверкой условия.

Переменные, объявленные в этом выражении, доступны только до конца блока `if`.

(Попробуйте использовать `v` в последнем операторе `return`.)

.play flowcontrol/if-with-a-short-statement.go

* If и else

Переменные, объявленные внутри короткого выражения `if`, также доступны внутри любых
блоков `else`.

(Оба вызова `pow` возвращают свои результаты до того, как вызов `fmt.Println`
в `main` начинается.)

.play flowcontrol/if-and-else.go

* Упражнение: Циклы и функции

В качестве способа поиграть с функциями и циклами, давайте реализуем функцию квадратного корня: для заданного числа x мы хотим найти число z, для которого z² наиболее близко к x.

Компьютеры обычно вычисляют квадратный корень из x, используя цикл.
Начиная с некоторого предположения z, мы можем корректировать z в зависимости от того, насколько z² близко к x,
получая лучшее предположение:

	z -= (z*z - x) / (2*z)

Повторение этой корректировки делает предположение все лучше и лучше,
пока мы не достигнем ответа, который настолько близок к фактическому квадратному корню, насколько это возможно.

Реализуйте это в предоставленной функции `func`Sqrt`.
Хорошее начальное предположение для z - это 1, независимо от входных данных.
Для начала повторите вычисление 10 раз и выведите каждое значение z.
Посмотрите, насколько близко вы подойдете к ответу для различных значений x (1, 2, 3, ...)
и как быстро улучшается предположение.

Подсказка: Чтобы объявить и инициализировать значение с плавающей точкой,
используйте синтаксис с плавающей точкой или преобразование:

	z := 1.0
	z := float64(1)

Затем измените условие цикла так, чтобы он останавливался, как только значение перестает
изменяться (или изменяется только на очень малую величину).
Посмотрите, это больше или меньше, чем 10 итераций.
Попробуйте другие начальные предположения для z, например x или x/2.
Насколько результаты вашей функции близки к [[https://golang.org/pkg/math/#Sqrt][math.Sqrt]] из стандартной библиотеки?

(*Примечание:* Если вас интересуют детали алгоритма, то z² − x выше
показывает, насколько z² далеко от того, где оно должно быть (x), а деление на 2z - это производная
от z², чтобы масштабировать, насколько мы корректируем z в зависимости от того, как быстро меняется z².
Этот общий подход называется [[https://en.wikipedia.org/wiki/Newton%27s_method][методом Ньютона]].
Он хорошо работает для многих функций, но особенно хорошо для квадратного корня.)

.play flowcontrol/exercise-loops-and-functions.go

* Switch

Оператор `switch` - это более короткий способ написать последовательность операторов `if`-`else`.
Он выполняет первый случай, значение которого равно выражению условия.

Switch в Go похож на switch в C, C++, Java, JavaScript и PHP,
за исключением того, что Go выполняет только выбранный случай, а не все последующие случаи.
По сути, оператор `break`, который необходим в конце каждого случая в этих
языках, в Go предоставляется автоматически.
Еще одно важное отличие состоит в том, что случаи switch в Go не обязательно
должны быть константами, и значения не обязательно должны быть целыми числами.

.play flowcontrol/switch.go

* Порядок вычисления в switch

Случаи switch вычисляются сверху вниз, останавливаясь, когда случай успешен.

(Например,

	switch i {
	case 0:
	case f():
	}

не вызывает `f`, если `i==0`.)

#appengine: *Примечание:* Время в Go playground всегда начинается с
#appengine: 2009-11-10 23:00:00 UTC, значение которого оставлено как
#appengine: упражнение для читателя.

.play flowcontrol/switch-evaluation-order.go

* Switch без условия

Switch без условия - это то же самое, что `switch`true`.

Эта конструкция может быть чистым способом написания длинных цепочек if-then-else.

.play flowcontrol/switch-with-no-condition.go

* Defer

Оператор defer откладывает выполнение функции до тех пор, пока окружающая
функция не вернет результат.

Аргументы отложенного вызова вычисляются немедленно, но вызов функции
не выполняется до тех пор, пока окружающая функция не вернет результат.

.play flowcontrol/defer.go

* Стек отложенных вызовов

Отложенные вызовы функций помещаются в стек. Когда функция возвращает результат, ее
отложенные вызовы выполняются в порядке "последний-вошел-первый-вышел".

Чтобы узнать больше об операторах defer, прочитайте эту
[[https://blog.golang.org/defer-panic-and-recover][запись в блоге]].

.play flowcontrol/defer-multi.go

* Поздравляем!

Вы закончили этот урок!

Вы можете вернуться к списку [[/list][модулей]], чтобы узнать, что изучать дальше, или продолжить со [[javascript:click('.next-page')][следующим уроком]].
