Методы и интерфейсы
Этот урок охватывает методы и интерфейсы, конструкции, которые определяют объекты и их поведение.

Авторы Go
https://golang.org

* Методы

В Go нет классов.
Однако вы можете определять методы для типов.

Метод - это функция со специальным аргументом _получателем_.

Получатель появляется в своем собственном списке аргументов между ключевым словом `func` и
именем метода.

В этом примере метод `Abs` имеет получателя типа `Vertex` с именем `v`.

.play methods/methods.go

* Методы - это функции

Помните: метод - это просто функция с аргументом-получателем.

Вот `Abs`, написанный как обычная функция без изменения функциональности.

.play methods/methods-funcs.go

* Методы (продолжение)

Вы также можете объявлять методы для неструктурных типов.

В этом примере мы видим числовой тип `MyFloat` с методом `Abs`.

Вы можете объявить метод только с получателем, тип которого определен в том же
пакете, что и метод.
Вы не можете объявить метод с получателем, тип которого определен в другом
пакете (включая встроенные типы, такие как `int`).

.play methods/methods-continued.go

* Указатели в качестве получателей

Вы можете объявлять методы с получателями-указателями.

Это означает, что тип получателя имеет буквальный синтаксис `*T` для некоторого типа `T`.
(Также, `T` сам по себе не может быть указателем, например, `*int`.)

Например, метод `Scale` здесь определен для `*Vertex`.

Методы с получателями-указателями могут изменять значение, на которое указывает получатель
(как это делает `Scale` здесь).
Поскольку методам часто нужно изменять своего получателя, получатели-указатели более
распространены, чем получатели-значения.

Попробуйте удалить `*` из объявления функции `Scale` в строке 16
и посмотрите, как изменится поведение программы.

С получателем-значением метод `Scale` работает с копией исходного
значения `Vertex`.
(Это то же самое поведение, что и для любого другого аргумента функции.)
Метод `Scale` должен иметь получателя-указателя, чтобы изменить значение `Vertex`,
объявленное в функции `main`.

.play methods/methods-pointers.go

* Указатели и функции

Здесь мы видим методы `Abs` и `Scale`, переписанные как функции.

Снова попробуйте удалить `*` из строки 16.
Видите, почему поведение меняется?
Что еще вам нужно было изменить, чтобы пример скомпилировался?

(Если вы не уверены, продолжайте на следующую страницу.)

.play methods/methods-pointers-explained.go

* Методы и косвенное обращение через указатель

Сравнивая две предыдущие программы, вы можете заметить, что
функции с аргументом-указателем должны принимать указатель:

	var v Vertex
	ScaleFunc(v, 5)  // Ошибка компиляции!
	ScaleFunc(&v, 5) // OK

в то время как методы с получателями-указателями принимают либо значение, либо указатель в качестве
получателя при их вызове:

	var v Vertex
	v.Scale(5)  // OK
	p := &v
	p.Scale(10) // OK

Для выражения `v.Scale(5)`, даже если `v` - это значение, а не указатель,
метод с получателем-указателем вызывается автоматически.
То есть, для удобства, Go интерпретирует выражение `v.Scale(5)` как
`(&v).Scale(5)`, поскольку метод `Scale` имеет получателя-указателя.

.play methods/indirection.go

* Методы и косвенное обращение через указатель (2)

Аналогичная вещь происходит и в обратном направлении.

Функции, которые принимают аргумент-значение, должны принимать значение этого конкретного типа:

	var v Vertex
	fmt.Println(AbsFunc(v))  // OK
	fmt.Println(AbsFunc(&v)) // Ошибка компиляции!

в то время как методы с получателями-значениями принимают либо значение, либо указатель в качестве
получателя при их вызове:

	var v Vertex
	fmt.Println(v.Abs()) // OK
	p := &v
	fmt.Println(p.Abs()) // OK

В этом случае вызов метода `p.Abs()` интерпретируется как `(*p).Abs()`.

.play methods/indirection-values.go

* Выбор получателя-значения или получателя-указателя

Есть две причины использовать получателя-указателя.

Первая - чтобы метод мог изменять значение, на которое указывает его получатель.

Вторая - чтобы избежать копирования значения при каждом вызове метода.
Это может быть более эффективно, если получатель - большая структура, например.

В этом примере оба метода `Scale` и `Abs` имеют тип получателя `*Vertex`,
хотя методу `Abs` не нужно изменять своего получателя.

В общем, все методы для данного типа должны иметь либо получателей-значений, либо получателей-указателей,
но не смесь обоих.
(Мы увидим, почему, на следующих нескольких страницах.)

.play methods/methods-with-pointer-receivers.go

* Интерфейсы

_Тип_интерфейса_ определяется как набор сигнатур методов.

Значение типа интерфейса может содержать любое значение, которое реализует эти методы.

*Примечание:* В примере кода есть ошибка в строке 22.
`Vertex` (тип значения) не реализует `Abser`, потому что
метод `Abs` определен только для `*Vertex` (типа указателя).

.play methods/interfaces.go

* Интерфейсы реализуются неявно

Тип реализует интерфейс, реализуя его методы.
Нет явного объявления намерения, нет ключевого слова "implements".

Неявные интерфейсы отделяют определение интерфейса от его
реализации, которая может затем появиться в любом пакете без предварительной договоренности.

.play methods/interfaces-are-satisfied-implicitly.go

* Значения интерфейсов

Под капотом значения интерфейсов можно рассматривать как кортеж значения и
конкретного типа:

	(значение, тип)

Значение интерфейса содержит значение конкретного базового типа.

Вызов метода для значения интерфейса выполняет метод с тем же именем для
его базового типа.

.play methods/interface-values.go

* Значения интерфейсов с нулевыми базовыми значениями

Если конкретное значение внутри самого интерфейса равно nil,
метод будет вызван с получателем nil.

В некоторых языках это вызвало бы исключение нулевого указателя,
но в Go обычно пишут методы, которые корректно обрабатывают вызов
с получателем nil (как метод `M` в этом примере).

Обратите внимание, что значение интерфейса, которое содержит нулевое конкретное значение, само по себе не является nil.

.play methods/interface-values-with-nil.go

* Нулевые значения интерфейсов

Нулевое значение интерфейса не содержит ни значения, ни конкретного типа.

Вызов метода для нулевого интерфейса - это ошибка времени выполнения, потому что нет
типа внутри кортежа интерфейса, который бы указывал, какой _конкретный_ метод вызывать.

.play methods/nil-interface-values.go

* Пустой интерфейс

Тип интерфейса, который не указывает методы, известен как _пустой_интерфейс_:

	interface{}

Пустой интерфейс может содержать значения любого типа.
(Каждый тип реализует по крайней мере ноль методов.)

Пустые интерфейсы используются кодом, который обрабатывает значения неизвестного типа.
Например, `fmt.Print` принимает любое количество аргументов типа `interface{}`.

.play methods/empty-interface.go

* Утверждения типа

_Утверждение_типа_ предоставляет доступ к базовому конкретному значению интерфейса.

	t := i.(T)

Это выражение утверждает, что значение интерфейса `i` содержит конкретный тип `T`
и присваивает базовое значение `T` переменной `t`.

Если `i` не содержит `T`, выражение вызовет панику.

Чтобы _проверить_, содержит ли значение интерфейса определенный тип,
утверждение типа может возвращать два значения: базовое значение
и логическое значение, которое сообщает, успешно ли выполнено утверждение.

	t, ok := i.(T)

Если `i` содержит `T`, то `t` будет базовым значением, а `ok` будет true.

Если нет, `ok` будет false, а `t` будет нулевым значением типа `T`,
и паника не возникнет.

Обратите внимание на сходство между этим синтаксисом и синтаксисом чтения из карты.

.play methods/type-assertions.go

* Переключатели типов

_Переключатель_типов_ - это конструкция, которая позволяет выполнять несколько утверждений типа подряд.

Переключатель типов похож на обычный оператор switch, но случаи в переключателе
типов указывают типы (не значения), и эти значения сравниваются с
типом значения, содержащегося в данном значении интерфейса.

	switch v := i.(type) {
	case T:
		// здесь v имеет тип T
	case S:
		// здесь v имеет тип S
	default:
		// нет совпадения; здесь v имеет тот же тип, что и i
	}

Объявление в переключателе типов имеет тот же синтаксис, что и утверждение типа `i.(T)`,
но конкретный тип `T` заменяется ключевым словом `type`.

Этот оператор switch проверяет, содержит ли значение интерфейса `i`
значение типа `T` или `S`.
В каждом из случаев `T` и `S` переменная `v` будет типа
`T` или `S` соответственно и будет содержать значение, содержащееся в `i`.
В случае по умолчанию (где нет совпадения) переменная `v` имеет
тот же тип интерфейса и значение, что и `i`.

.play methods/type-switches.go

* Stringers

Один из самых распространенных интерфейсов - [[//golang.org/pkg/fmt/#Stringer][`Stringer`]], определенный пакетом [[//golang.org/pkg/fmt/][`fmt`]].

	type Stringer interface {
		String() string
	}

`Stringer` - это тип, который может описать себя как строку. Пакет `fmt`
(и многие другие) ищут этот интерфейс для печати значений.

.play methods/stringer.go

* Упражнение: Stringers

Сделайте так, чтобы тип `IPAddr` реализовал `fmt.Stringer` для печати адреса
в виде четырех чисел, разделенных точками.

Например, `IPAddr{1,`2,`3,`4}` должен печататься как `"1.2.3.4"`.

.play methods/exercise-stringer.go

* Ошибки

Программы Go выражают состояние ошибки с помощью значений `error`.

Тип `error` - это встроенный интерфейс, похожий на `fmt.Stringer`:

	type error interface {
		Error() string
	}

(Как и с `fmt.Stringer`, пакет `fmt` ищет интерфейс `error` при
печати значений.)

Функции часто возвращают значение `error`, и вызывающий код должен обрабатывать ошибки,
проверяя, равна ли ошибка `nil`.

	i, err := strconv.Atoi("42")
	if err != nil {
		fmt.Printf("не удалось преобразовать число: %v\n", err)
		return
	}
	fmt.Println("Преобразованное целое число:", i)

Нулевая `error` обозначает успех; ненулевая `error` обозначает неудачу.

.play methods/errors.go

* Упражнение: Ошибки

Скопируйте функцию `Sqrt` из [[/flowcontrol/8][предыдущего упражнения]] и измените ее, чтобы она возвращала значение `error`.

`Sqrt` должна возвращать ненулевое значение ошибки, когда ей дается отрицательное число, так как она не поддерживает комплексные числа.

Создайте новый тип

	type ErrNegativeSqrt float64

и сделайте его `error`, дав ему метод

	func (e ErrNegativeSqrt) Error() string

такой, что `ErrNegativeSqrt(-2).Error()` возвращает `"не`могу`вычислить`квадратный`корень`из`отрицательного`числа:`-2"`.

*Примечание:* Вызов `fmt.Sprint(e)` внутри метода `Error` отправит программу в бесконечный цикл. Вы можете избежать этого, сначала преобразовав `e`: `fmt.Sprint(float64(e))`. Почему?

Измените функцию `Sqrt`, чтобы она возвращала значение `ErrNegativeSqrt`, когда ей дается отрицательное число.

.play methods/exercise-errors.go

* Readers

Пакет `io` определяет интерфейс `io.Reader`,
который представляет конец потока данных для чтения.

Стандартная библиотека Go содержит [[https://golang.org/search?q=Read#Global][множество реализаций]] этого интерфейса, включая файлы, сетевые соединения, компрессоры, шифры и другие.

Интерфейс `io.Reader` имеет метод `Read`:

	func (T) Read(b []byte) (n int, err error)

`Read` заполняет данными переданный байтовый срез и возвращает количество заполненных
байтов и значение ошибки. Он возвращает ошибку `io.EOF`, когда поток
заканчивается.

Пример кода создает
[[//golang.org/pkg/strings/#Reader][`strings.Reader`]]
и потребляет его вывод по 8 байт за раз.

.play methods/reader.go

* Упражнение: Readers

Реализуйте тип `Reader`, который выдает бесконечный поток символов ASCII
`'A'`.

.play methods/exercise-reader.go

* Упражнение: rot13Reader

Распространенный шаблон - это [[https://golang.org/pkg/io/#Reader][io.Reader]], который оборачивает другой `io.Reader`, изменяя поток каким-либо образом.

Например, функция [[https://golang.org/pkg/compress/gzip/#NewReader][gzip.NewReader]] принимает `io.Reader` (поток сжатых данных) и возвращает `*gzip.Reader`, который также реализует `io.Reader` (поток распакованных данных).

Реализуйте `rot13Reader`, который реализует `io.Reader` и читает из `io.Reader`, изменяя поток путем применения шифра подстановки [[https://en.wikipedia.org/wiki/ROT13][rot13]] ко всем алфавитным символам.

Тип `rot13Reader` предоставлен вам.
Сделайте его `io.Reader`, реализовав его метод `Read`.

.play methods/exercise-rot-reader.go

* Изображения

[[https://golang.org/pkg/image/#Image][Пакет image]] определяет интерфейс `Image`:

	package image

	type Image interface {
		ColorModel() color.Model
		Bounds() Rectangle
		At(x, y int) color.Color
	}

*Примечание*: возвращаемое значение `Rectangle` метода `Bounds` на самом деле
[[https://golang.org/pkg/image/#Rectangle][`image.Rectangle`]], так как
объявление находится внутри пакета `image`.

(См. [[https://golang.org/pkg/image/#Image][документацию]] для всех деталей.)

Типы `color.Color` и `color.Model` также являются интерфейсами, но мы проигнорируем это, используя предопределенные реализации `color.RGBA` и `color.RGBAModel`. Эти интерфейсы и типы определены пакетом [[https://golang.org/pkg/image/color/][image/color]]

.play methods/images.go

* Упражнение: Изображения

Помните [[/moretypes/18][генератор изображений]], который вы написали ранее? Давайте напишем еще один, но на этот раз он будет возвращать реализацию `image.Image` вместо среза данных.

Определите свой собственный тип `Image`, реализуйте [[https://golang.org/pkg/image/#Image][необходимые методы]] и вызовите `pic.ShowImage`.

`Bounds` должен возвращать `image.Rectangle`, например, `image.Rect(0,`0,`w,`h)`.

`ColorModel` должен возвращать `color.RGBAModel`.

`At` должен возвращать цвет; значение `v` в последнем генераторе изображений соответствует `color.RGBA{v,`v,`255,`255}` в этом.

.play methods/exercise-images.go

* Поздравляем!

Вы закончили этот урок!

Вы можете вернуться к списку [[/list][модулей]], чтобы узнать, что изучать дальше, или продолжить со [[javascript:click('.next-page')][следующим уроком]].
